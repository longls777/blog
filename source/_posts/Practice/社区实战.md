---
title: 社区架构（SpringBoot+MySQL+Redis）
tags: 
categories: Practice
date: 2023-04-08 20:38:00
index_img: 
banner_img: 
---

## 数据库表

**用户表**

![image-20230408210719390](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408210719390.png)

```sql
CREATE TABLE `user` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(50) DEFAULT NULL,
  `password` varchar(50) DEFAULT NULL,
  `salt` varchar(50) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `type` int DEFAULT NULL COMMENT '0-普通用户; 1-超级管理员; 2-版主;',
  `status` int DEFAULT NULL COMMENT '0-未激活; 1-已激活;',
  `activation_code` varchar(100) DEFAULT NULL,
  `header_url` varchar(200) DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_username` (`username`(20)),
  KEY `index_email` (`email`(20))
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**讨论贴表**

![image-20230408210740808](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408210740808.png)

```sql
CREATE TABLE `discuss_post` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` varchar(45) DEFAULT NULL,
  `title` varchar(100) DEFAULT NULL,
  `content` text,
  `type` int DEFAULT NULL COMMENT '0-普通; 1-置顶;',
  `status` int DEFAULT NULL COMMENT '0-正常; 1-精华; 2-拉黑;',
  `create_time` timestamp NULL DEFAULT NULL,
  `comment_count` int DEFAULT NULL,
  `score` double DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**信息表**

![image-20230408210800571](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408210800571.png)

```sql
CREATE TABLE `message` (
  `id` int NOT NULL AUTO_INCREMENT,
  `from_id` int DEFAULT NULL,
  `to_id` int DEFAULT NULL,
  `conversation_id` varchar(45) NOT NULL,
  `content` text,
  `status` int DEFAULT NULL COMMENT '0-未读;1-已读;2-删除;',
  `create_time` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_from_id` (`from_id`),
  KEY `index_to_id` (`to_id`),
  KEY `index_conversation_id` (`conversation_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**评论表**

![image-20230408210842413](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408210842413.png)

```sql
CREATE TABLE `comment` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL,
  `entity_type` int DEFAULT NULL,
  `entity_id` int DEFAULT NULL,
  `target_id` int DEFAULT NULL,
  `content` text,
  `status` int DEFAULT NULL,
  `create_time` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */,
  KEY `index_entity_id` (`entity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**登陆凭证表**

![image-20230408210827648](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408210827648.png)

```sql
CREATE TABLE `login_ticket` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int NOT NULL,
  `ticket` varchar(45) NOT NULL,
  `status` int DEFAULT '0' COMMENT '0-有效; 1-无效;',
  `expired` timestamp NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_ticket` (`ticket`(20))
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```



## 实体

**User**

![image-20230408212318250](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408212318250.png)

**Page**

![image-20230408212829416](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408212829416.png)

**DiscussPost**

![image-20230408212846297](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408212846297.png)

**Comment**

![image-20230408212923234](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408212923234.png)

**LoginTicket**

![image-20230408213206414](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408213206414.png)



DAO和mapper不再记录，就是一些增删改查操作，看源码



## 用户注册和激活

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/clipboard.png)

**用户注册和激活流程：**

1. 值检测（check value），包括传入值是否有效，账号邮箱是否已经被注册等
2. 注册账号，使用UUID前五位作为salt，和密码concat然后md5加密，设置激活码为UUID

![image-20230408214223149](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408214223149.png)

3. 发送激活邮件，使用userID和激活码作为激活URL，使用Thylemeaf模板引擎生成邮件正文内容

![image-20230408214508509](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408214508509.png)

4. 用户访问邮件中的激活URL，比对和数据库中存储的激活码

![image-20230408214812825](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408214812825.png)

这里有一个@PathVariable 注释，可以将请求URL中的占位符（即路径变量）绑定到控制器方法的参数上

![image-20230408215140085](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408215140085.png)



> 为什么要在密码中加salt？https://blog.csdn.net/zhuzj12345/article/details/84324700
>
> MD5是一种hash算法，以512位分组来处理输入的信息，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。
>
> 首先需要对齐填充，使字节数%512=448 然后加上64位的数据长度信息，最终得到512的整倍数。
>
> MD5无法反向解密，原因是MD5对原始消息进行的是有损的压缩计算。
>
> 但是可以通过加密庞大的密码数据集来暴力碰撞，暴力破解。
>
> salt 随机产生，数据库中存储的密码为 MD5( 明文密码 + Salt)，这样就无法直接匹配
>
> 如果想要通过＋salt 再MD5来暴力碰撞 ，那么需要的计算量极其庞大：
>
> 假设用户库有30w条数据，黑客数据字典有600w条数据，那么如果想完全破解所有密码，
>
> 需要加密 300000  * 6000000 = 一万八千亿 次MD5运算，因为每条潜在密码都需要＋所有的salt 再进行计算
>
> 当然，如果只想破解一个用户的密码，只需要 600w次MD5运算，那也是比较大的计算量了
>
> 实际项目中，可以把salt加在明文密码中间，这样可以大大提高破解难度

## 用户登录和退出

![clipboard2](http://longls777.oss-cn-beijing.aliyuncs.com/img/clipboard2.png)

**用户登录流程**

1. 首先生成验证码，将验证码内容存入HttpSession，图片传入HttpServletResponse

![image-20230408220221737](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408220221737.png)

2. 登陆时，判断验证码是否正确，并根据是否“记住我”确定ticket超时时间

![image-20230408220606198](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408220606198.png)

3. 值检测，包括验证是否激活，验证密码等

![image-20230408220804748](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408220804748.png)

4. 生成登陆凭证（ticket），其中ticket字段是一个UUID

![image-20230408221216211](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408221216211.png)

5. 将ticket字段作为cookie返回

![image-20230408221358487](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408221358487.png)



**用户退出流程**

1. 从请求中取出ticket

![image-20230408222358944](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408222358944.png)

2. 设置数据库中对应ticket过期

![image-20230408222451805](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408222451805.png)



## 登录拦截



![clipboard3](http://longls777.oss-cn-beijing.aliyuncs.com/img/clipboard3.png)

1. 设置注解@LoginRequired

![image-20230408222728271](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408222728271.png)

2. 使用ThreadLocal代替session持有用户信息

![image-20230408223129635](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230408223129635.png)



> 好处是什么？https://zhuanlan.zhihu.com/p/26713362
>
> 通常在项目中，用户登录后，我们会将用户的信息存到session，如果想在其它地方获取session中的用户信息，我们需要先获取HttpServletRequest，再通过request.getSession得到HttpSession，从而获取到我们想要的用户信息。
>
> 这样就需要需要传入一个HttpServletRequest，
>
> 在SpringMVC中，我们只要在一个controller方法参数里显式加上HttpServletRequest参数也可以轻松获取，
>
> 这样如果想要在service层和dao层就要用到session中的用户信息，就需要调用service的时候，将用户信息以参数形式传过去（service层和dao层都是和web层分离开来，都是单独的工程，不依赖servlet api，）
>
> 如此一来，代码就不够简洁优雅，所有我们想要获取用户信息的方法都要多加一个参数，增强了依赖，和我们想要的“松耦合”背道而弛。
>
> 对于session中的用户信息，我们不仅想要在controller中随用随取，还想在其它普通类中取，即使不依赖servlet api， 我们也要在方法里随用随取，anywhere！
>
> 为了解决这个问题，我们就要采取一种新的方法来存储用户信息—ThreadLocal
>
> 每个请求都会对应一个线程，这个ThreadLocal就是这个线程使用过程中的一个变量，该变量为其所属线程所有，各个线程互不影响
>
> 所以我们可以借助这个ThreadLocal来存储登录用户的信息，在一个请求中，所有调用的方法都在同一个线程中去处理，这样就实现了在任何地方都可以获取到用户信息了，从而摆脱了HttpServletRequest的束缚。
>
> 然后我们在拦截器里就可以根据Ticket获取到的user，将user注册到ThreadLocal里面
>
> 以后就可以在方法里随取随用

3. 设置LoginTicketInterceptor，将user存储到HostHolder

![image-20230409211754366](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230409211754366.png)

4. 设置在postHandle返回登录用户（在请求处理完成后，返回 View 前执行）；afterCompletion清空HostHolder（在请求处理完成后执行，无论是否出现异常，都会执行该方法）

![image-20230409212111019](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230409212111019.png)

5. 在LoginRequiredInterceptor拦截器中，设置登陆验证。首先判断处理器是否为 HandlerMethod，即请求是否被映射到了具体的方法上，如果不是，则直接返回 true，继续处理后续的拦截器或处理器。如果是 HandlerMethod，就通过反射获取该方法上是否有 @LoginRequired 注解。如果有该注解，就判断当前用户是否登录，即判断 HostHolder 中是否存在用户信息。如果 HostHolder 中不存在用户信息，则将请求重定向到登录页面，并返回 false，中断请求的继续传递。如果没有 @LoginRequired 注解或用户已经登录，则直接返回 true，继续处理后续的拦截器或处理器。

![image-20230409212332433](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230409212332433.png)

> 为什么要先判断处理器是否为 HandlerMethod？
>
> 在 Spring MVC 中，一个请求的处理过程需要经过多个处理器的处理，而处理器可以是 Controller 类或方法。而 HandlerInterceptor 的拦截目标是方法，因此在 preHandle 方法中需要判断处理器是否为 HandlerMethod 类型，只有是 HandlerMethod 类型，才能通过反射获取方法上是否有 @LoginRequired 注解，从而实现登录验证功能。
>
> 所有能被分配给 Controller 方法处理的请求都是 HandlerMethod 类型的，而不能被分配给 Controller 方法处理的请求，如静态资源请求，就不是 HandlerMethod 类型。
>
> 如果不判断处理器是否为 HandlerMethod 类型，而是直接通过反射获取方法上是否有 @LoginRequired 注解，那么对于一些静态资源，如图片、css、js 等请求，因为它们并没有对应的方法来处理请求，这个判断就会出现错误，无法正确判断是否需要登录验证，进而影响应用程序的正常运行。



> 这里如何利用反射？
>
> 这里利用反射的原理是通过 `HandlerMethod` 获取方法对象 `Method`，再通过 `Method` 获取方法上的 `LoginRequired` 注解

6. 配置拦截器，包括拦截顺序，排除一些静态资源申请等

![image-20230409213257589](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230409213257589.png)

## 敏感词过滤

**Trie树算法**

```java
@Component
public class SensitiveFilter {

    //logger日志
    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    //用于替换敏感词的短句
    private static final String REPLACEMENT = "***";

    //根节点
    private TrieNode rootNode = new TrieNode();

    //该注解表示在构造器执行之后 执行初始化
    @PostConstruct
    public void init(){//初始化用来加载敏感词文件
        try(
                InputStream is = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
           ) {
            String keyword;
            while((keyword = reader.readLine())!=null){

                this.addKeyword(keyword);
            }
        } catch (Exception e) {
            logger.error("加载敏感词文件失败： " + e.getMessage());
        }

    }

    //添加敏感词到前缀树，也就是前缀树的初始化
    private void addKeyword(String Keyword){
        TrieNode tempNode = rootNode;
        for(int i=0;i<Keyword.length();i++){
            char c = Keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);
            if(subNode==null){
                //初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c,subNode);
            }
            tempNode = subNode;

            //结束标识
            if(i==Keyword.length()-1){
                tempNode.setKeywordEnd(true);
            }
        }
    }

    /**
     * 过滤敏感词
     * @param text 待过滤文本
     * @return  过滤后文本
     */
    public String filter(String text){
        if(StringUtils.isBlank(text)){
            return null;
        }

        TrieNode tempNode = rootNode;
        int begin = 0;
        int position = 0;
        StringBuilder sb = new StringBuilder();

        while(position<text.length()){
            char c = text.charAt(position);

            //跳过符号
            if(isSymbol(c)){
                 if(tempNode == rootNode){//表示begin==position
                     sb.append(c);
                     begin++;
                 }
                 position++;
                 continue;
            }

            //检查下级节点
            tempNode = tempNode.getSubNode(c);

            //分三种情况讨论
            if(tempNode==null) {//表示没有以begin开头的敏感词
                sb.append(text.charAt(begin));
                position = ++begin;
                tempNode = rootNode;
            }else if(tempNode.isKeywordEnd()){//表示查找到一个敏感词
                sb.append(REPLACEMENT);
                begin = ++position;
                tempNode = rootNode;
            }else{//查找敏感词的过程中
                position++;
            }
        }

        //为了避免最后position到达length而begin还在前面时 发生的begin之后的文本的丢失
        //当begin=length时，substring方法返回空字符串，不会抛出异常
        //begin>length时，substring才会抛出异常
        sb.append(text.substring(begin));

        return sb.toString();
    }


    //判断是否为符号
    private boolean isSymbol(Character c){
        //0x2E80~0x9FFF 东亚文字范围，表示只有当该字符属于符号且不属于东亚文字时，才返回true，被真正判定为符号
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c >  0x9FFF);
    }


    //前缀树节点 内部类
    private class TrieNode{

        private boolean isKeywordEnd = false;//关键词结束标志
        private Map<Character,TrieNode> subNodes = new HashMap<>();//储存下级节点

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        //添加子节点
        public void addSubNode(Character c,TrieNode node){
            subNodes.put(c,node);
        }

        //获取子节点
        public TrieNode getSubNode(Character c){
            return subNodes.get(c);
        }

    }
}
```

