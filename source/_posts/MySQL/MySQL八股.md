---
title: MySQL
tags: 八股
categories: MySQL
date: 2023-5-4 13:25:00
index_img: 
banner_img: 
math: true
---

# 一、事务ACID特性

**说说事务的ACID特性？**

数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）

![事务](http://longls777.oss-cn-beijing.aliyuncs.com/img/事务.png)

**1. 原子性（Atomicity）**

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

**2. 一致性（Consistency）**

数据库在事务执行前后都保持一致性状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。通过保证事务的原子性、隔离性和持久性，来保证事务的一致性。

**3. 隔离性（Isolation）**

一个事务在最终提交以前，对其它事务是不可见的。每个读写事务的对象对其他事务的操作对象是相互分离的。

**4. 持久性（Durability）**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

# 二、并发一致性问题

**说说数据库并发事务会出现哪些问题？**

**丢失修改**

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。 在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 

例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207221744244.png)

**脏读**

脏读是指一个事务读取了另一个事务尚未提交的更改数据。当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。当前者回滚时，后者读到的数据是不合法的，称为脏读

例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207221920368.png)

**不可重复读**

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。

例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207222102010.png)

**幻读**

幻读与不可重复读类似，它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

例如：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207222134306.png)

**幻读和不可重复读的区别在于：**

幻读对应新增（insert）数据，不可重复读对应更改（update）或者删除（delete）数据，对于不可重复读，只需要采用行级锁防止该记录数据被更改或删除，而对于幻读，则必须加表级锁，防止其他事务在这个表中新增数据。

对于前者,  只需要锁住满足条件的记录

对于后者,  要锁住满足条件及其相近的记录

**MySQL（Innodb）是如何解决幻读的？**

在一次事务里面，多次查询之后，结果集的个数不一致的情况叫做幻读。

首先我们的SELECT查询分为快照读和实时读，快照读通过MVCC（并发多版本控制）来解决幻读问题，实时读通过行锁来解决幻读问题。

因为MySQL默认的隔离级别是可重复读，这种隔离级别下，我们普通的SELECT语句都是快照读，也就是在一个事务内，多次执行SELECT语句，查询到的数据都是事务开始时那个状态的数据（这样就不会受其他事务修改数据的影响），这样就解决了幻读的问题。

> 快照读也叫一致性非锁定读，不需要等待锁的释放就可以读取，该实现通过undo log来完成，在RR和RC级别下，Innodb使用快照读，然而实现上有所不同，RR下总是读取事务开始时的行数据版本，而RC下读取最新的行数据版本，从数据库理论的角度而言，RC下的快照读违反了事务的隔离性
>
> 另外还有一致性锁定读，需要对查询语句显式地加锁
>
> 　SELECT...FOR UPDATE 
>
> 　SELECT...LOCK IN SHARE MODE
>
> SELECT...FOR UPDATE对读取的行记录加一个X锁
>
> SELECT...LOCK IN SHARE MODE对读取的行记录加一个S锁

如果说快照读总是读取事务开始时那个状态的数据，实时读就是查询总是执行这个查询时数据库中的数据。

一般使用以下这两种查询语句进行查询时就是实时读：

```sql
SELECT *** FOR UPDATE 在查询时会先申请X锁  
SELECT *** LOCK IN SHARE MODE 在查询时会先申请S锁
```

在这种情况下，我们执行第一次 SELECT...FOR UPDATE查询语句是，其实是会先申请行锁，如果一开始数据库就只有a:4一行数据，那么加锁区间其实是

(负无穷，4](4,正无穷)

我们查询条件是a>2，上面两个加锁区间都会可能有数据满足条件，所以会申请行锁中的next-key lock，是会对上面这两个区间都加锁，这样其他事务不能往这两个区间插入数据，事务B执行插入时会一直等待获取锁，直到事务A提交，释放行锁，事务B才有可能申请到锁，然后进行插入。这样就解决了幻读问题

> https://zhuanlan.zhihu.com/p/145766112

# 三、事务隔离级别

**说说事务的隔离级别？**

SQL 标准定义了四个隔离级别：

- READ-UNCOMMITTED（读取未提交）： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ-COMMITTED（读取已提交）： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE-READ（可重复读）： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生（在只读时是可以避免幻读的；在读写时可能会因为update操作使得不可见的行变得可见，从而出现幻影行）
- SERIALIZABLE（可串行化）： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）

> [MySQL InnoDB RR(可重复读)隔离级别能否解决幻读](https://gaoooyh.github.io/2021-09-28-MySQL-InnoDB-RR(%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB)%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%83%BD%E5%90%A6%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB)

# 四、封锁

**1. 讲讲MySQL的封锁？**

**封锁粒度**

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

**封锁类型**

1. 读写锁

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207213523777.png)

2. 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

各种锁的兼容关系如下：

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207214442687.png)

解释如下：

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

**封锁协议**

**1. 三级封锁协议**

**一级封锁协议**

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207220440451.png)

**二级封锁协议**

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决脏读问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207220831843.png)

**三级封锁协议**

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/207221313819.png)

**2. 两段锁协议**

在一个事务里面，分为加锁（lock）阶段和解锁（unlock）阶段，也即所有的lock操作都在unlock操作之前

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/clipboard.png)

引入2PL是为了保证事务的隔离性，即多个事务在并发的情况下等同于串行的执行。

在实际情况下，SQL是千变万化、条数不定的，数据库很难在事务中判定什么是加锁阶段，什么是解锁阶段。于是引入了S2PL（Strict-2PL），即:

1. 在事务中只有提交（commit）或者回滚（rollback）时才是解锁阶段，
2. 其余时间为加锁阶段。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/2pl.png)

**MySQL 隐式与显示锁定**

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定： 

```sql
SELECT ... LOCK In SHARE MODE; 
SELECT ... FOR UPDATE;
```

**2. 如何减少行锁对性能的影响？**

> https://blog.csdn.net/sinat_27143551/article/details/103033433 好文

- 根据两段锁协议，将并发加锁的语句靠近提交语句，这样可以减少加锁时间

- 死锁和死锁检测：

- - 设置死锁超时时间innodb_lock_wait_timeout 不好，时间长了等待时间长，时间短了可能回滚简单的锁等待

  - 建议开启主动死锁检测 innodb_deadlock_detect

  - - 热点行死锁检测消耗大量的cpu资源，如何解决？

    - - 对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作，可以通过中间件实现，或者修改MySQL源码
      - 通过设计上优化，比如将余额的1行改为10行，最后累加，不过需要仔细设计业务逻辑

如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：

- 第一种，直接执行 delete from T limit 10000;
- 第二种，在一个连接中循环执行 20 次 delete from T limit 500;
- 第三种，在 20 个连接中同时执行 delete from T limit 500。

你会选择哪一种方法呢？为什么呢？

答案：

- 方案一，事务相对较长，则占用锁的时间较长，会导致其他客户端等待资源时间较长。
- 方案二，串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作，同时也意味着将资源分片使用（每次执行使用不同片段的资源），可以提高并发性。
- 方案三，人为自己制造锁竞争，加剧并发量。

# 五、MCVV

**讲讲InnoDB的MVCC**

多版本并发控制（Multi-Version Concurrency Control，MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

**基本思想**

MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

**版本号**

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

**Undo Log**

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo Log中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a"); 
UPDATE t SET x="b" WHERE id=1; 
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 START TRANSACTION 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

![](http://longls777.oss-cn-beijing.aliyuncs.com/img/208164808217.png)

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1

**快照读与当前读**

1. 快照读

MVCC 的 SELECT 操作是针对快照中的数据，不需要进行加锁操作。

```sql
SELECT * FROM table ...;
```

2. 当前读

MVCC 会对其它对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

```sql
INSERT; 
UPDATE; 
DELETE;
```

在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。

```sql
SELECT * FROM table WHERE ? lock in share mode; 
SELECT * FROM table WHERE ? for update;
```

# 六、B+树

...