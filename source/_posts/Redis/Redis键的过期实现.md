---
title: Redis键的过期实现
tags: 
categories: Redis
date: 2023-2-15 11:40:00
index_img: 
banner_img: 
math: true
---

## 1. 过期时间的保存

redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：

- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键)
- 过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳

![image-20230215114244616](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215114244616.png)

## 2. 过期键的删除策略

- **定时删除**：在设置键的过期时间的同时，创建一个定时器（timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作
- **惰性删除**：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键
- **定期删除**：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定

这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略

#### 定时删除

- **优点**：对内存友好，尽快释放过期键所占用的内存
- **缺点**：
  - 对CPU时间不友好，删除过期键会占用一部分CPU时间，可能会对服务器的响应时间和吞吐量造成影响
  - 创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式—无序链表，查找一个事件的时间复杂度为O(N)—并不能高效地处理大量时间事件

因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实

#### 惰性删除

- **优点**：对CPU时间最友好，只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间
- **缺点**：对内存最不友好，过期键会占用内存而得不到及时释放，如果不被访问的话甚至可能永远不被删除，可以看作是一种内存泄漏

> 举个例子，对于一些和时间有关的数据，比如日志（ log)，在某个时间点之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户以为服务器已经自动将它们删除了，但实际上这些键仍然存在，而且健所占用的内存也没有释放，那么造成的后果肯定是非常严重的

#### 定期删除

从上面对定时删除和惰性删除的讨论来看，这两种删除方式在单一使用时都有明显的缺陷：

- **定时删除**：占用太多CPU时间，影响服务器的响应时间和吞吐量
- **惰性删除**：浪费太多内存，有内存泄漏的危险

定期删除策略是前两种策略的一种整合和折中：

- 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响
- 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费

定期删除策略的难点是确定删除操作执行的时长和频率：

- 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面
- 如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况

**因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率**

## 3. Redis所使用的过期键删除策略

Redis服务器实际使用的是**惰性删除**和**定期删除**两种策略:通过配合使用这两种删除策略，服务器可
以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡

#### 惰性删除策略的实现

过期键的惰性删除策略由db.c/expireIfNeeded函数实现，**所有读写数据库的Redis命令在执行之前都会调用expireTfNeeded函数对输人键进行检查**：

- 如果输入键已经过期，那么expireIfNeeded函数将输人键从数据库中删除
- 如果输入键未过期，那么expireIfNeeded函数不做动作

![image-20230215115938340](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215115938340.png)

expireIfNeeded函数就像一个过滤器，**它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键**

另外，因为每个被访问的键都可能因为过期而被expireIfNeeded函数删除，所以每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：

- 当键存在时，命令按照键存在的情况执行
- 当键不存在或者键因为过期而被expireIfNeeded函数删除时，命令按照键不存在的情况执行

![image-20230215120038348](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215120038348.png)

#### 定期删除策略的实现

过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，**它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键**

## 4. AOF、RDB和复制功能对过期键的处理

#### 生成RDB文件

在执行**SAVE**命令或者**BGSAVE**命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

因此，数据库中包含过期键不会对生成新的RDB文件造成影响

#### 载入RDB文件

在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

- 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响
- 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响

#### AOF文件写入

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响

当过期键被惰性删除或者定期删除之后，程序会向AOF 文件追加（append）一条DEL命令，来显式地记录该键已被删除

举个例子，如果客户端使用GET message命令，试图访问过期的message键，那么服务器将执行以下三个动作：

1. 从数据库中删除message键
2. 追加一条DEL message命令到AOF文件
3. 向执行GET命令的客户端返回空回复

#### AOF重写

和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中

因此，数据库中包含过期键不会对AOF重写造成影响

#### 复制

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：

- 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键
- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键

通过由主服务器来控制从服务器统一地删除过期键，**可以保证主从服务器数据的一致性**，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。

