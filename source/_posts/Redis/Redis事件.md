---
title: Redis事件
tags: 
categories: Redis
date: 2023-2-21 22:25:00
index_img: 
banner_img: 
math: true
---

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

- **文件事件（file event）**：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作
- **时间事件（time event）**：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象

## 文件事件

Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）：

- 文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性

![image-20230221223011000](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230221223011000.png)

![image-20230221223024054](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230221223024054.png)

尽管多个文件事件可能会并发地出现，但IO多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个套接字

![image-20230221223456482](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230221223456482.png)

## 时间事件

Redis 的时间事件分为以下两类：

- **定时事件**：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次
- **周期性事件**：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次



一个时间事件主要由以下三个属性组成：

- **id**：服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大
- **when**：毫秒精度的UNIX时间截，记录了时间事件的到达（arrive）时间
- **timeProc**：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件



一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：

- 如果事件处理器返回ae.h/AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达
- 如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达

> 目前版本的 Redis只使用周期性事件，而没有使用定时事件

#### 时间事件的实现

服务器将所有时间事件都放在一个**无序链表**中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器

![image-20230221223935842](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230221223935842.png)

> 注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理

**无序链表并不影响时间事件处理器的性能**

在目前版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，而在benchmark模式下，服务器也只使用两个时间事件。在这种情况下，**服务器几乎是将无序链表退化成一个指针来使用**，所以使用无序链表来保存时间事件，并不影响事件执行的性能

#### 时间事件应用实例：serverCron函数

持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：

- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等
- 清理数据库中的过期键值对
- 关闭和清理连接失效的客户端
- 尝试进行AOF或RDB持久化操作
- 如果服务器是主服务器，那么对从服务器进行定期同步
- 如果处于集群模式，对集群进行定期同步和连接测试

Redis服务器以周期性事件的方式来运行serverCron函数，在服务器运行期间，每隔一段时间，servercron就会执行一次，直到服务器关闭为止

## 事件的调度与执行

事件的调度和执行由ae.c/aeProcessEvents函数负责，以下是该函数的伪代码表示：

```python
def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    
	# 计算最接近的时问事件距高到达还有多少毫秒
	remaind_ms = time_event.when - unix_ts_now()
    
	# 如果事件已到达，那么remaind_ms的值可能为负数，将它设定为0
    if remaind_ms < 0:
		remaind_ms = 0
	# 根据remaind_ms的值，创建timeval结构
	timeval = create_timeva1_with_ms(remaind_ms)

    # 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
	# 如果remaind_ms的值为0，那么aeApipoll调用之后马上返回，不阻塞
    aeApiPoll(timeval)
    
    # 处理所有已产生的文件事件
    processFileEvents()
	# 处理所有已到达的时间事件
	processTimeEvents()
```



![image-20230221224839515](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230221224839515.png)

以下是事件的调度和执行规则：

- aeApiPoll函数的**最大阻塞时间由到达时间最接近当前时间的时间事件**决定，这个方法**既可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保aeApiPoll函数不会阻塞过长时间**。
- 因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了
- 对文件事件和时间事件的处理都是**同步、有序、原子地**执行的，**服务器不会中途中断事件处理，也不会对事件进行抢占**，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写人到客户端套接字时，如果写人字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写入循环，将余下的数据留到下次再写；另外，**时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行**
- 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以**时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些**

