---
title: Redis的数据类型
tags: 
categories: Redis
date: 2023-2-14 13:37:00
index_img: 
banner_img: 
math: true
---

## Redis常用的五种数据类型（五种对象）

Redis是一种存储key-value的内存型数据库，它的key都是字符串类型，value支持存储5种类型的数据：

- String（字符串类型）
- List（列表类型）
- Hash（哈希表类型、即key-value类型）
- Set（无序集合类型，元素不可重复）
- Zset（有序集合类型，元素不可重复）

这五种数据类型的对象都由一个redisObject结构表示：

![image-20230214134925649](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214134925649.png)

- type：记录对象的类型，可以是下表中的任一个：

![image-20230214135105820](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214135105820.png)

可以对一个数据库键使用TYPE命令，获取此数据库键对应的值对象的类型：

![image-20230214135411221](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214135411221.png)

- encoding：记录对象使用的编码，也就是对象的底层数据结构，可以是下表中的任一个：![image-20230214135730965](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214135730965.png)

每种数据类型的对象都至少使用了两种不同的编码，下表列出了每种数据类型的对象可以使用的编码：

![image-20230214140042228](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214140042228.png)

使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码：

![image-20230214140204190](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214140204190.png)

> Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。
> 举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中;
> 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面

### 字符串对象（string）

字符串对象的编码可以是int、raw或embstr

- int：字符串对象保存的是整数值，并且这个整数值可以用long来表示
- raw：字符串对象保存的是字符串值，且长度大于32字节
- embstr：字符串对象保存的是字符串值，且长度小于32字节

> embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构
>
> 使用embstr编码的字符串对象来保存短字符串值有以下好处：
> embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

最后要说的是，可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值：

![image-20230214142845803](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214142845803.png)

在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面：

![image-20230214142945136](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214142945136.png)

![image-20230214143303902](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214143303902.png)

> 因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序)，所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。

### 列表对象（list）

列表对象的编码可以是ziplist或者linkedlist

- ziplist：压缩列表，满足以下两个条件时使用ziplist
- linkedlist：双端链表，不满足时使用linkedlist

> 两个条件：
>
> - 列表对象保存的所有字符串元素的长度都小于64字节
> - 列表对象保存的元素数量小于512个

![image-20230214163213727](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214163213727.png)

![image-20230214163223406](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230214163223406.png)

> 注意，linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现，字符串对象是Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象

### 哈希对象（hash）

哈希对象的编码可以是ziplist或者hashtable

![image-20230215093606923](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215093606923.png)

![image-20230215093918275](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215093918275.png)

> 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：
>
> - 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
> - 哈希对象保存的键值对数量小于512个
>
> 不能满足这两个条件的哈希对象需要使用hashtable 编码



### 集合对象（set）

集合对象的编码可以是intset或者hashtable

- intset：整数集合
- hashtable：字典的键是字符串对象，储存集合元素，值为空

![image-20230215094520005](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215094520005.png)

> 当集合对象可以同时满足以下两个条件时，对象使用intset编码：
>
> - 集合对象保存的所有元素都是整数值
> - 集合对象保存的元素数量不超过512个
>
> 不能满足这两个条件的集合对象需要使用hashtable 编码

### 有序集合对象（zset）

有序集合的编码可以是ziplist或者skiplist

- ziplist：一个节点保存成员member，一个节点保存score，按score从小到大排序
- skiplist：使用zset作为底层实现，一个zset结构包含一个字典和一个跳跃表

![image-20230215095013884](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215095013884.png)

![image-20230215095603602](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230215095603602.png)

zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。

除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用O(1)复杂度查找给定成员的分值，ZSCORE命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。

值得一提的是，虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会**通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存**。

> **为什么有序集合需要同时使用跳跃表和字典来实现?**
>
> 在理论上，有序集合可以单独使用字典或者跳跃袅的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。
>
> 举个例子，如果我们只使用字典来实现有序集合，那么虽然以O(1)复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作─—比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O(NlogN)时间复杂度，以及额外的O(N)内存空间（因为要创建一个数组来保存排序后的元素)。
>
> 另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升为O(logN)。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

> 当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：
>
> - 有序集合保存的元素数量小于128个
> - 有序集合保存的所有元素成员的长度都小于64字节
>
> 不能满足以上两个条件的有序集合对象将使用skiplist 编码