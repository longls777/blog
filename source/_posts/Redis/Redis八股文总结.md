---
title: Redis八股总结
tags: 八股
categories: Redis
date: 2023-3-20 14:59:00
index_img: 
banner_img: 
math: true
---

## 一、关系型数据库和非关系型数据库的区别？

关系型数据库是指采用了关系模型来组织数据的数据库，关系模型指的就是二维表格模型，数据按照表的形式存储，然后多组表构成了一个数据库。

**优点：**

1. 易于维护：都是使用表结构，格式一致
2. 使用方便：支持SQL语言，可用于复杂查询

**缺点：**

1. 读写性能比较差，尤其是海量数据的高效率读写
2. 固定的表结构，灵活性差
3. 对于高并发读写需求，硬盘I/O是一个很大的瓶颈



非关系型数据库严格上不是一种数据库，应该是一种**数据结构化存储方法的集合**，可以是文档或者键值对等

**优点：**

1. 格式灵活：存储数据格式可以是key-value格式，文档格式，图片格式等等，使用灵活，应用场景广泛，而关系型数据库只支持基础的数据类型
2. 速度快：Nosql可以使用硬盘或者随机存储器（RAM，内存）作为载体，而关系型数据库只能使用硬盘
3. 高扩展性：Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展

**缺点：**

1. 不支持SQL
2. 无事务处理（ACID）
3. 只适合存储一些较为简单的数据，需要进行较复杂查询的数据，关系型数据库显的更为合适

## 二、什么是Redis？

Redis是用C语言编写的，开源的高性能非关系型数据库（Nosql），是一个高性能的key-value数据库

Redis可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值的类型可以为字符串，List列表，Set集合， Zset有序集合，Hash散列表

与传统数据库不同的是Redis的数据库是存储于内存中的，读写速度非常快，所以Redis被广泛应用于缓存方向，每秒可以处理超过10w次读写操作，是已知性能最快的key-value DB；

此外，Redis也经常用来做分布式锁。而且Redis还支持事务，持久化，LUA脚本，LRU驱动事件，多种集群方案

## 三、Redis的优缺点？

**优点：**

1. 读写性能优异
2. 支持数据持久化——AOF持久化和RDB持久化
3. 支持事务，Redis的所有操作都是原子性的
4. 数据结构丰富，除了支持String类型之外，还支持hash，set，zset，list等数据结构
5. 支持主从复制，主机会自动将数据同步到从机，可进行**读写分离**

**缺点：**

1. 数据库容量容易受到物理内存的限制，不能用作高性能海量数据读写，因此Redis主要适用于较小数据量的高性能操作和运算上
2. Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写需求失败，需要等待机器重启或者手动切换前端的IP才能恢复
3. 主机宕机，宕机前有部分数据未能同步到从机，切换IP后会引入数据不一致的问题
4. Redis较难支持在线扩容，在集群容量达到上限时，扩容会变得很复杂；所有运维人员在系统上线时必须确保足够的空间，这对资源造成很大的浪费

> **关于读写分离**
>
> 随着业务的不断扩大，请求的并发量不断增长，Redis可能终会出现无法负载的情况，此时我们就需要想办法去提升Redis的负载能力
>
> 读写分离（主从复制）是一个比较简单的扩展方案，使用多台机器同时运行Redis服务，一台负责写服务，多台负责读服务，通过多台服务器对请求进行负载，大大提高了Redis服务的负载压力。这样从节点也可以支持横向扩展，来继续提高读的吞吐量
>
> ![Redis读写主从分离](https://img-blog.csdnimg.cn/img_convert/f332a6c58c2db4454ccc5c9f04d6766c.webp?x-oss-process=image/format,png)



## 四、Redis持久化——RDB 和 AOF？

**RDB持久化**可以在指定时间间隔内生成数据集的时间点快照

在默认情况下， Redis将内存数据库快照保存在名字为dump.rdb 的二进制文件中

`save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可`

以上设置会让Redis在满足“60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集： 


**AOF持久化**是记录服务器执行的所有读写操作命令，并在服务器启动时，通过执行这些命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾

> 可以配置 Redis 多久才将数据 fsync 到磁盘一次。 有三个选项：
>
> 1. appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全
>
> 2. appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据
>
> 3. appendfsync no：从不fsync ，将数据同步交给操作系统来处理。更快，也更不安全的选择

Redis还可以在后台对AOF文件进行重写，使AOF文件的体积不会超出保存数据集状态所需的实际大小

Redis还可以同时使用RDB和AOF持久化。在这种情况下，当Redis重启时，他会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整

![image-20230320163536954](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230320163536954.png)

## 五、为什么要用Redis/为什么要用缓存？

主要从**高性能**和高并发这两个角度来看待问题

**高性能：**

假如用户第一次访问数据库中的某些数据，这个过程是比较慢的，因为是从硬盘上直接读取的。将该用户访问的数据存储在缓存中，这样下次再次访问这些数据的时候，就可以直接去缓存中拿了。操作缓存就是直接操作内存，所以速度特别快。数据库中的数据改变后，同步改变缓存中相应的数据即可

**高并发：**

直接操作缓存所能承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户中的一部分请求会直接到缓存中，而不是数据库

## 六、Redis有多快，为什么这么快？

单机Redis读取的速度是11w次/s，写的速度是8.1w次/s

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
2. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 使用I/O 多路复用模型，非阻塞 IO

## 七、Redis有哪些数据类型？*

Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，具体可看Redis的数据结构一节

## 八、Redis的过期键和删除策略？

过期键删除策略通常有以下三种

1. **定时删除**：在设置键的过期时间的同时，创建一个定时器（timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存很友好，但是会占用大量CPU去处理过期的数据，从而影响响应时间和吞吐量
2. **惰性删除**：只有当访问一个key时，才会去判断这个Key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，但对内存十分不友好，极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存
3. **定期删除**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果

## 九、Redis的内存淘汰策略？*

**全局的键空间选择性移除**

- no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（常用）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key

**设置过期时间的键空间选择性移除**

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中， 移除最近最少使用的key
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除将要过期的key，ttl的值越大优先被移除

> Redis的内存淘汰策略的选取并不会影响过期的key的处理
>
> 内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据

## 十、Redis到底是不是单线程的？

Redis是单线程的：通常说的单线程，主要是指Redis对外提供的键值存储服务的主要流程是单线程，也就是网络I/O和数据读写是由单个线程来完成的

除此之外Redis的其他功能，例如持久化，异步删除，集群数据同步等，是由额外线程来执行的

因此，严格来说Redis并不是全面单线程

## 十一、Redis I/O多路复用*



## 十二、Redis事务相关的命令

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH四个原语实现的，Redis会将一个事务中的所有命令序列化，然后按顺序执行

- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS） 行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令
- MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行
- EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值nil
-  通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。
- UNWATCH命令可以取消watch对所有key的监控

## 十三、Redis与事务ACID



## 十四、Redis主从复制



## 十五、Redis哨兵模式



## 十六、Redis缓存击穿



## 十七、Redis缓存雪崩



## 十八、Redis分片


































Redis什么情况下会发生数据丢失？

Redis在线扩容？



> https://blog.csdn.net/weixin_47188125/article/details/125706438