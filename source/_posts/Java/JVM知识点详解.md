---
title: JVM知识点详解
tags: 八股
categories: Java
date: 2023-4-25 16:42:00
index_img: 
banner_img: 
math: true
---

# 一、Java运行时数据区

**1. 说说Java运行时数据区？**

![Java运行时数据区](http://longls777.oss-cn-beijing.aliyuncs.com/img/Java运行时数据区.png)

线程私有的：

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的：

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

**堆**

- Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的目的就是存放对象实例，几乎所有的**对象实例**以及**数组**都在这里分配内存。
- 从 JDK 1.7 开始已经默认开启逃逸分析，如果某些对象没有被其他方法或线程调用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
- Java堆也是垃圾回收的主要区域，因此也被称作GC 堆，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。
- Java堆在物理上可以不连续，只要逻辑上连续就好。堆可以动态地增加内存，如果增加失败，就会抛出 OutOfMemoryError。

**堆上对象的访问方式**

  通过对栈上局部变量表中的reference数据来操纵堆上的对象

-   使用句柄：Java堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

![使用句柄](http://longls777.oss-cn-beijing.aliyuncs.com/img/使用句柄.png)

-  直接指针： reference 中存储的直接就是对象的地址，在对象中存储指向对象数据类型的指针

![直接指针](http://longls777.oss-cn-beijing.aliyuncs.com/img/直接指针.png)

-   比较：使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

**方法区**

- 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码（JIT编译的热点代码）等数据。
- 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
- 在JDK1.8之前，HotSpot 虚拟机把方法区当成永久代来进行垃圾回收，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。
- 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的运行时常量池中的字符串常量池移入堆中，其他数据全部放入元空间中。

**运行时常量池**

- 运行时常量池是方法区的一部分。
- Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。

- - 字面量：字符串；八种基本类型的值；final常量
  - 符号引用：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符

- 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。空间不足会抛出OutOfMemoryError 异常

> [浅谈String.intern()方法](https://blog.csdn.net/u011635492/article/details/81048150)

**虚拟机栈**

![虚拟机栈](http://longls777.oss-cn-beijing.aliyuncs.com/img/虚拟机栈.png)

- Java虚拟机栈是线程私有的
- 每个 Java 方法在执行的同时会创建一个栈帧用于存储**局部变量表**、**操作数栈**（运算区域）、**常量池引用**等信息。**从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。**
- Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。

- - StackOverFlowError： 当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出StackOverFlowError 异常。可能是方法递归次数太多
  - OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

**本地方法栈**

- 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
- 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。

**程序计数器**

-   每个线程都需要一个独立的程序计数器
-   记录正在执行的虚拟机**字节码指令**的地址
-   字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
-   在多线程的情况下，程序计数器用于**记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**2. 为什么要将永久代替换为元空间呢？**

- 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，容易造成性能问题和内存溢出，而元空间使用的是直接内存，受本机可用内存的限制，这样加载多少类就不由 MaxPermSize 控制了， 而由系统的实际可用空间来控制
- 在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西， 合并之后就没有必要额外的设置这么一个永久代的地方了

> （以下来自chatGPT）
>
> 元数据（Metadata）指的是描述数据的数据，也就是数据的属性、定义或说明。在计算机科学中，元数据通常用于描述数据的结构、格式、类型、含义、来源、存储位置等信息，以及数据的版本、权限、生命周期等管理信息。元数据可以帮助应用程序理解数据的意义和用途，从而更加高效地对数据进行处理和管理。
>
> 在Java语言中，元数据通常指的是描述Java类、方法、字段、注解等程序元素的信息。Java中的元数据可以通过反射API来获取和修改，它包含了许多有用的信息，如类的名称、继承关系、接口实现、方法的参数和返回值类型、注解的定义等。元数据在Java中也被广泛应用，如在Web应用程序中用于配置、在注解处理器中用于生成代码、在IDE中用于代码提示和自动完成等。
>
> 在Java虚拟机中，元数据通常存储在永久代（JDK8之前）或元空间（JDK8及之后）中，用于支持类加载、字节码解释、动态编译、垃圾回收等功能。由于元数据的数量通常非常大，因此对元数据的高效存储和管理对于JVM的性能和稳定性至关重要。

# 二、判断对象存活状态

**如何判断对象已经死亡？**

**1. 引用计数法**

为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1，引用计数为 0 的对象可被回收。

在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此主流 Java 虚拟机不使用引用计数算法。

**2. 可达性分析算法**

以 GC Roots 为起始点进行搜索，走过的路径称为引用链，可达的对象都是存活的，不可达的对象可被回收。

可以作为GC Roots的对象包括：

- 虚拟机栈中局部变量表中引用的对象（reference）

- 本地方法栈中 JNI （Java Native Interface）中引用的对象
- 方法区中类静态属性引用的对象（静态对象成员）
- 方法区中的常量引用的对象

**真的死了吗？**

  要真正宣告一个对象的死亡，需要至少两次标记过程，可达性分析中判断为不可达的对象被第一次标记并进行一次筛选，当对象没有覆盖finalize()方法或者finalize()方法被调用过时，虚拟机认为对象没有必要执行finalize()方法，直接将其回收。

需要执行的对象被放入一个队列中等待执行finalize() 方法，如果在此之前重新建立引用，那么就可以将其移出队列，否则就会真的被回收。

即使对象第一次逃出被回收的命运，第二次也会直接被回收，因为它的finalize()方法已经被调用过一次了。

任何对象的finalize()方法都只会被调用一次。

> [Java对象回收与finalize方法](https://www.cnblogs.com/XiaoZhengYu/p/12884565.html)
>
> https://www.cnblogs.com/qfchen/p/11322134.html

# 三、强软弱虚引用

**说说Java中的引用类型？**

**1. 强引用**

- 被强引用关联的对象不会被回收，即使内存空间不足而抛出OOM异常
- 可以使用 new 一个新对象的方式来创建强引用

**2 . 软引用**

- 被软引用关联的对象只有在内存不够的情况下才会被回收
- 软引用可以用来实现内存敏感的高速缓存
- 使用 SoftReference 类来创建软引用

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

**3. 弱引用**

- 被弱引用关联的对象一定会被回收，就是说它只能存活到下一次垃圾回收发生之前
- 使用 WeakReference 类来创建弱引用 

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

**4. 虚引用**

- 虚引用任何时候都可以被垃圾回收
- 主要用来跟踪对象被垃圾回收器回收的活动
- 使用 PhantomReference 来创建虚引用

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

# 四、垃圾回收算法

**说说有哪些垃圾回收算法？**

**1. 标记-清除算法（Mark and Sweep）**

![标记-清除算法](http://longls777.oss-cn-beijing.aliyuncs.com/img/标记-清除算法.png)

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它存在两个问题：

- 标记和清除的效率不高
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存

**2. 标记-整理算法（Mark and Compact）**

![标记-整理算法](http://longls777.oss-cn-beijing.aliyuncs.com/img/标记-整理算法.png)

让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存

优点：

- 不会产生内存碎片

缺点：

- 需要移动对象，效率比较低

**3. 复制算法（Copying）**

![复制算法](http://longls777.oss-cn-beijing.aliyuncs.com/img/复制算法.png)

- 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理
- 主要不足是只使用了内存的一半
- 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor（From）。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor (To)上，最后清理 Eden 和使用过的那一块 Survivor（下一次From和To交换位置）
- HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象

**4. 分代收集算法（Generational）**

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法

一般将堆分为新生代和老年代

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法

# 五、垃圾收集器

**1. 说说垃圾收集器？**

**1. Serial收集器**

![Serial垃圾收集器](http://longls777.oss-cn-beijing.aliyuncs.com/img/Serial垃圾收集器.png)

- 串行收集器，单线程，只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束
- 一般用于新生代回收
- 使用复制算法

**2. ParNew收集器**

![ParNew垃圾收集器](http://longls777.oss-cn-beijing.aliyuncs.com/img/ParNew垃圾收集器.png)

- Serial收集器的多线程版本
- 标记-复制算法
- 是CMS默认的新生代垃圾回收器，除了 Serial 收集器外，只有它能与 CMS 配合工作

**3. Paraller Scavenge收集器**

- 多线程收集器，与ParNew类似
- 目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值
- 高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务

**4. Serial Old收集器**

- Serial收集器的老年代版本，同样是一个单线程收集器
- 使用标记-整理算法

**5. Paraller Old收集器**

- Parallel Scavenge 收集器的老年代版本，多线程
- 在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器

**6. CMS（Concurrent Mark Sweep）收集器**

- 一种以**获取最短回收停顿时间**为目标的老年代收集器。它非常符合在注重用户体验的应用上使用

- 是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作

- 采用“**标记-清除算法**”，包括四个步骤：

- - 初始标记： 暂停所有的其他线程，并记录下**直接**与GC root 相连的对象，速度很快（Stop The World）
  - 并发标记： 同时开启 GC 和用户线程，从GC root继续向下进行标记，但是用户线程会继续更新对象的引用域
  - 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短（Stop The World）
  - 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫

- ![CMS](http://longls777.oss-cn-beijing.aliyuncs.com/img/CMS.png)

优点是并发收集、停顿时间短

缺点是：

- 标记-清除算法会产生内存碎片
- 无法处理浮动垃圾，浮动垃圾就是在并发标记过程中新垃圾，这部分只能等到下次GC时才会被处理
- 对 CPU 资源敏感，在并发过程中会和用户线程一起抢占CPU

> **什么是浮动垃圾？**
>
> 在并发标记阶段本来可达的对象，由于用户线程的作用变得不可达了，即产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终导致这些新产生的垃圾对象没有被及时回收
>
> **在重新标记阶段会修正由于用户线程运作而导致对象的标记产生变动的记录，那为什么还有浮动垃圾产生？**
>
> 由于标记阶段是从 GC Roots开始标记可达对象，那么在并发标记阶段可能产生两种变动：
>
> - 本来可达的对象，变得不可达了
> - 本来不可达的对象，变得可达了
>
> 如果在并发标记阶段中，用户线程new了一个对象，而它在初始标记和并发标记中无法从GC Roots可达，如果没有重新标记阶段将这个对象标记为可达，那么在并发清除阶段被回收，这是严重的错误
>
> 相比之下，浮动垃圾是可容忍的问题，那为什么重新标记阶段不处理第一种变动呢？由于从可达变为不可达的变化需要重新从GC Roots开始遍历，相当于再次完成初始标记和并发标记的工作，这样会造成增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS不能容忍的。

**7. G1收集器**

- 唯一一个可以**同时用于新生代和老年代**的垃圾收集器

- 该收集器将堆划分为多个大小相等的Region，并维护了一个**优先列表**，每次根据允许的收集时间，优先回收价值最大的 Region

- 每个 Region 都有一个 Remembered Set用来记录引用关系，使得在可达性分析的时候避免全堆扫描

- 分为以下四个步骤：

- - 初始标记（类似CMS）
  - 并发标记（类似CMS）
  - 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，**虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中**。这阶段需要停顿线程，但是可并行执行
  - 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

- 特点：

- - 并发性强
  - **标记-复制**算法不会产生内存碎片
  - 可以预测停顿时间

- ![G1](http://longls777.oss-cn-beijing.aliyuncs.com/img/G1.png)

> [G1](https://juejin.cn/post/7087702205897113636)

**8.ZGC**

ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。

**ZGC原理**

**全并发的ZGC**

与CMS中的ParNew和G1类似，ZGC也采用**标记-复制算法**，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

ZGC垃圾回收周期如下图所示：

![ZGC](http://longls777.oss-cn-beijing.aliyuncs.com/img/ZGC.jpeg)



ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都**只需要扫描所有GC Roots**，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，**ZGC几乎所有暂停都只依赖于GC Roots集合大小**，**停顿时间不会随着堆的大小或者活跃对象的大小而增加**。与ZGC对比，G1的转移阶段完全STW，且停顿时间随存活对象的大小增加而增加。

**ZGC关键技术**

ZGC通过**着色指针**和**读屏障**技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。

**着色指针**

> 着色指针是一种将信息存储在指针中的技术。

ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间，如下图所示：

![ZGC划分子空间](http://longls777.oss-cn-beijing.aliyuncs.com/img/ZGC划分子空间.png)



其中，[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。

当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。后续章节将详细介绍这三个空间的切换过程。

与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0 ~ 41位，而第42 ~ 45位存储元数据，第47~63位固定为0。

![ZGC存储方式](http://longls777.oss-cn-beijing.aliyuncs.com/img/ZGC存储方式.jpeg)

ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。

**读屏障**

> 读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。

读屏障示例：

```java
Object o = obj.FieldA   // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o  // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i =  obj.FieldB  //无需加入屏障，因为不是对象引用
```

ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。

**ZGC并发处理演示**

接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：

- 初始化：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。
- 并发标记阶段：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。
- 并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。

其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。即第二次进入并发标记阶段后，地址视图调整为M1，而非M0。

着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。

![读屏障](http://longls777.oss-cn-beijing.aliyuncs.com/img/读屏障.jpeg)



> https://zhuanlan.zhihu.com/p/170572432 美团技术团队

**2. 为什么要Stop The World？**

可达性分析算法中，枚举根节点(GC ROOT)会导致所有java程序执行线程停顿。

- 分析工作必须在一个能确保一致性的快照中进行
- 一致性指整个分析期间整个执行系统像被冻结在某个时间点上
- 如果出现分析过程中对象引用关系还在不断地变化，则分析结果的准确性无法保证

举个例子，如果分析时判断该对象已经没有引用，而分析后下一秒该对象又有了引用，则GC时会将该对象清理，导致错误发生。

# 六、内存分配和回收策略

**1. 说说Minor GC和Full GC？**

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多

**2. Full GC 的触发条件？**

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

- 老年代空间不足：老年代空间不足的常见场景就是大对象直接进入老年代、长期存活的对象进入老年代等。

- - 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold （默认15）调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

- 空间分配担保失败：使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC
- 调用 System.gc()：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

**3. 说说有哪些内存分配策略？**

**1. 对象优先在 Eden 分配**

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC

**2. 大对象直接进入老年代**

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。（数组也是对象）

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

**3. 长期存活的对象进入老年代**

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

**4. 动态对象年龄判定**

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

# 七、类加载机制

**说说JVM的类加载机制？**

类的生命周期：

![类的生命周期](http://longls777.oss-cn-beijing.aliyuncs.com/img/类的生命周期.png)

虚拟机把描述类的数据从class文件加载到内存 的 类加载过程分为：

- 加载
- 验证
- 准备
- 解析
- 初始化

**加载**

- 通过类的全限定名获取定义该类的二进制字节流；
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口
- 简单点：就是将class文件从磁盘读到内存

**验证**

为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 ，其实就是验证字节码文件的正确性

![字节码文件验证流程](http://longls777.oss-cn-beijing.aliyuncs.com/img/字节码文件验证流程.png)

**准备**

正式为类变量（static修饰，也就是静态变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配

![数据类型的零值](http://longls777.oss-cn-beijing.aliyuncs.com/img/数据类型的零值.png)

> 这里的初始值指的是数据类型的默认值，而不是代码中所赋的值。例如：
>
> public static int value = 1 ；
>
> 在准备阶段之后，value值为0，而不是1。赋值为1的动作发生在初始化阶段。
>
> 但是，也要特殊情况，如果变量被static 和 final同时修饰，则准备阶段直接赋值为指定值。如：
>
> public finally static int value = 1 ；
>
> 在准备阶段之后，value的值即为1

**解析**

- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法等。
- 符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析其实就是把符号引用定位到直接引用，比如引用了classA的a字段，需要解析出这个a字段的值是属于classA还是属于classA继承的父类；使用了classA的b方法，需要解析出这个b方法是classA实现的还是继承自父类的。具体可看下面的链接
- 也有说法是 **类加载器加载该类所引用的所有其它类**

> https://baijiahao.baidu.com/s?id=1658299223471945338&wfr=spider&for=pc



**初始化**

是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码（字节码）

> **类构造器 < clinit > 方法和实例构造器 < init > 方法有什么区别呢？**
>
> < clinit > 方法是在类加载的初始化阶段执行，是对静态变量、静态代码块进行的初始化。而< init > 方法是new一个对象，即调用类的 constructor方法时才会执行，是对非静态变量进行的初始化。

# 八、类加载器和双亲委派模型

**1. 说说类加载器？**

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader ，其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：

- **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。
- **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
- **ApplicationClassLoader(应用程序类加载器)** ：也叫系统类加载器，负责加载用户类路径classpath下的所有jar包和类。

**2. 说说双亲委派模型？**

- 每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。
- 即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
- 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。
- 当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

![双亲委派模型](http://longls777.oss-cn-beijing.aliyuncs.com/img/双亲委派模型1.png)

![双亲委派模型具体流程](http://longls777.oss-cn-beijing.aliyuncs.com/img/双亲委派模型2.png)

**双亲委派模型的好处**

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类

如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类（该类是胡编的）呢？该类并不存在java.lang中，经过双亲委派模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过**系统类加载器**？加载该类。但是这样做是不允许，因为**java.lang是核心API包**，需要访问权限，强制加载将会报出如下异常

`java.lang.SecurityException: Prohibited package name: java.lang`