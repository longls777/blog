---
title: Java八股总结
tags: 八股
categories: Java
date: 2023-4-9 22:17:00
index_img: 
banner_img: 
math: true
---

# 一、基础

**1. 说说什么是字节码?采用字节码的好处是什么?**

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

**2. 说说Java和C++的区别？**

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）

**3. 说说Java有哪些基本数据类型？**

| 基本类型 | 位数 | 字节 | 默认值  |
| -------- | ---- | ---- | ------- |
| int      | 32   | 4    | 0       |
| short    | 16   | 2    | 0       |
| long     | 64   | 8    | 0L      |
| byte     | 8    | 1    | 0       |
| char     | 16   | 2    | 'u0000' |
| float    | 32   | 4    | 0.0f    |
| double   | 64   | 8    | 0.0d    |
| boolean  | 1    |      | false   |

**4. 说说自动拆装箱？**

基本数据类型都有对应的包装类，装箱过程通过调用valueOf()方法实现，拆箱过程通过调用xxxValue()方法实现

```java
Integer a = 1; 
Integer b = 2; 
Integer c = 3; 
Long g = 3L; 
System.out.println(g==c);//报错，不会自动拆箱 
System.out.println(g==(a+b)); //true,遇到运算符才会自动拆箱 
System.out.println(g.equals(a+b));//false 
//关于最后一个，equals参数为包装类型，则先比较是否为同类型，非同类型直接返回false，同类型再比较值 
//a+b为Integer类型，与Long类型不一致，所以返回false
```

**5. 说说包装类的缓存池（常量池）？**

当使用比如new Integer(123)时，总会创建一个新的对象，而使用valueOf(123)时，会先判断值是否在缓存池中，如果在就直接返回缓存池中的内容

基本类型对应的缓冲池如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

float和double没有实现缓存池

**6. 说说final关键字？**

- 用来修饰数据：声明数据为常量，表示该数据只能被赋值一次且值无法修改，修饰的类变量必须在声明时初始化，修饰的实例变量必须在声明时或者构造方法中赋值

- - 对于基本类型，final 使数值不变；
  - 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的

- 修饰方法：声明方法不能被重写

- 修饰类：声明类无法被继承

**7. 说说static关键字**

- 修饰变量：静态变量只有一份，所有实例变量共享
- 修饰方法：静态方法，类加载的时候就存在了，可以通过“类名.方法名”调用
- 静态代码块：只会在类初次加载的时候执行一次，用来初始化
- 静态内部类：静态内部类不能访问外部类的非静态的变量和方法

**8. 初始化顺序**

- 父类–静态变量/父类–静态初始化块
- 子类–静态变量/子类–静态初始化块
- 父类–变量/父类–初始化块
- 父类–构造器
- 子类–变量/子类–初始化块
- 子类–构造器

**9.重载和重写**

**重载的规则：**

- 必须具有不同的参数列表
- 不能通过访问权限、返回类型、抛出的异常进行重载

**重写的规则：**

- 父类方法的参数列表必须完全与被子类重写的方法的参数列表相同，否则不能称其为重写而是重载
-  Java中规定，被子类重写的方法不能拥有比父类方法更加严格的访问权限
- 在继承过程中如果父类当中的方法抛出异常，那么在子类中重写父类的该方法时，也要抛出异常，而且抛出的异常不能多于父类中抛出的异常(可以等于父类中抛出的异常)。换句话说，重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。例如，父类的一个方法申明了一个检查异常IOException，在重写这个方法时就不能抛出Exception，只能抛出IOException的子类异常，可以抛出非检查异常

> 1、重载是一个编译期概念、重写是一个运行期间概念。
>
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
>
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
>
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

# 二、面向对象

**说说你是怎么理解Java的面向对象的？**

面向对象是向现实世界模型的自然延伸，这是一种”万物皆对象”的编程思想。在现实生活中的任何物体都可以归为一类事物，而每一个个体都是一类事物的实例，也就是说现实世界中每一个实体都是一个对象。在Java中，一切皆是对象。

面向对象具有三大特性：封装、继承、多态

**封装**

封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下：

- 保护类中的信息，阻止在外部定义的代码随意访问内部代码和数据
- 隐藏细节信息
- 松耦合
- 提高复用率

Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员方法来访问，这就可以确保不会发生不希望的事情。

**继承**

程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承

> Java为什么是单继承多实现的？
>
> 如果是多继承，那么如果父类中有重复的方法或者属性，子类调用时会无法判断；
>
> 而多实现没有这个问题，因为接口定义的方法最终要在子类里实现，所以不会出现混乱；对于接口的同名属性，由于接口属性都必须是 public static final修饰的，所以在编译时就会确定其值，如果有重复的接口成员常量，则编译不通过

**多态**

对象的多态性是指在父类中定义的属性或方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或方法在父类及其各个子类中具有不同的语义。

Java的多态性体现在两个方面：由方法重载实现的静态多态性（编译时多态）和方法重写实现的动态多态性（运行时多态）

- 编译时多态：在编译阶段，具体调用哪个被重载的方法，编译器会根据参数的不同来静态确定调用相应的方法。
- 运行时多态：一个对象可以通过引用子类的实例来调用子类的方法，具体调用的是哪个子类的方法是在程序运行时动态确定的。

重载：方法名相同，参数类型、个数或顺序不同，返回值类型、访问修饰符可以相同也可以不同

重写：方法名、参数列表、返回值类型必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。

# 三、访问权限

**1. 说说Java的访问权限修饰符？**

修饰符有四种：public、protected、默认、private

- public：表示所有其他类都可以访问。
- protected：当前类或子类可以访问，同时相同包内的其他类也可以访问protected成员；(protected实际上就是拓展了一下default，使得包外的子类可以访问，但也只能通过继承来访问，而不是通过创建父类对象访问)
- default :默认（没有修饰符）：表示本包内可以使用
- private：表示的是在本类内可以使用

|           | 类内部 | 本包 | 子类 | 外部包 |
| :-------: | :----: | :--: | :--: | :----: |
|  public   |   √    |  √   |  √   |   √    |
| protected |   √    |  √   |  √   |   ×    |
|  default  |   √    |  √   |  ×   |   ×    |
|  private  |   √    |  ×   |  ×   |   ×    |

**2. 子类可以访问不同包中父类的protected方法吗？**

可以，子类直接调用是可以访问的，子类通过父类对象调用是不能的

protected的含义是指子类可以访问，说的是子类直接访问父类的protected方法

而不是说子类中，可以调用父类的对象访问父类的protected方法

子类可以访问，可以在子类访问不是一个概念

> 详见https://www.cnblogs.com/noteless/p/9270015.html

但是包外子类可以通过父类对象调用其protected static方法，因为静态方法访问会被编译方法器静态绑定，而无需经过对象去访问方法表

> 详见https://blog.csdn.net/xiaoxiao_su123/article/details/119239477

# 四、参数传递

**Java方法的参数是值传递还是引用传递？**

Java里只有值传递

- 如果传递的是基本数据类型：传递进来的参数就是原参数的一个副本，如果在函数中改变了参数的值，原始的值不会改变
- 如果传递的是引用类型：传递进来的就是这个引用的副本，这个副本存储的是对象的地址，当在函数中改变这个引用时，对原来的对象没有影响，比如将这个引用指向了一个新的对象，但是当通过这个引用副本对内存中的对象进行改变时，原来的对象也会跟着一同改变
- 总之不管传递什么类型的参数，传递的都是副本，基本类型就是值的副本，引用类型就是地址的副本

# 五、抽象类和接口

**说说抽象类和接口的区别？**

**语法层面的区别**

- 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
- 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

**设计层面的区别**

抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。简单的说，抽象类是“是什么”，接口是“有没有”。

> https://www.cnblogs.com/dolphin0520/p/3811437.html very nice

# 六、类的创建过程

<img title="Java类的创建过程" src="http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230409223222791.png" style="max-width:30%;">



**①类加载检查：** 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

**②分配内存：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**

> **划分内存的方法：**
>
> **“指针碰撞”（Bump the Pointer）**
>
> 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
>
> **“空闲列表”（Free List）**
>
> 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

> **解决分配内存时并发问题的方法：**
>
> **CAS（compare and swap）**
>
> 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。
>
> **本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）**
>
> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。

**③初始化零值：** 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

**④设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

**⑤执行 init 方法：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来