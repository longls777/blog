---
title: Java并发知识点详解
tags: 八股
categories: Java
date: 2023-4-25 21:49:00
index_img: 
banner_img: 
math: true
---

# 一、Java内存模型（JMM）

**1. 说说Java内存模型（JMM）？**

![Java内存模型](http://longls777.oss-cn-beijing.aliyuncs.com/img/Java内存模型.png)

- JMM规定线程之间的所有共享变量（包括实例字段，静态字段和数组元素）存储在主内存中，每个线程有自己私有的工作内存，工作内存中存储的是主存中共享变量的副本
- 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据
- **一个线程不能直接访问其他线程的工作内存**
- 主内存和工作内存只是JMM的一个抽象概念，主内存主要对应于Java堆中的对象实例数据部分，而工作内存对应于虚拟机栈的部分区域；从更底层来看，主内存对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存
- JMM的目的是屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果

**2. 那么Java线程间是如何通信的？（联系到操作系统中进程间通信方式）**

- 共享内存：通过对主内存中的共享变量进行读-写来进行隐式通信
- 消息传递：线程之间通过发送消息进行显式通信
- Java并发采用的是共享内存，Java线程间的通信总是隐式进行的

**3. 说说Java内存模型中的原子性、可见性和有序性？**

**原子性**

- 指一个操作或者多个操作，要么都执行，并且不会被任何因素打断，要么都不执行
- JMM保证对基本数据类型的访问和读写都是具备原子性的
- synchronized关键字可以保证代码块的原子性

**可见性**

- 指当一个线程修改了共享变量的值，其他线程可以立即得知这个修改，就是一个线程修改的状态对另一个线程是可见的
- JMM通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种方式来实现可见性
- volatile关键字可以保证变量的可见性，volatile的特殊规则保证新值能够立即同步回主存，以及每次使用前立即从主存刷新
- synchronized关键字可以保证可见性，它规定对一个变量执行 unlock 操作之前，必须把变量值同步回主内存（unlock作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定）

**有序性**

- 指在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的
- 前半句是指“线程内表现为串行的语义（as-if-serial）”，后半句指的是“指令重排序”和“工作内存与主内存同步延迟”，**也就是说，在单线程中，指令重排序不会有危害，相反还会提高程序执行的效率，而在多线程中，指令重排序可能会造成意想不到的错误。**
- volatile关键字可以禁止指令重排序
- synchronized关键字通过“一个变量在同一时刻只允许一条线程对其进行lock操作”来保证有序性（lock作用于主内存的变量，它把一个变量标识为一条线程独占的状态）

**4. 什么是happens-before原则？**

由于存在线程本地内存和主内存的原因，再加上重排序，会导致多线程环境下存在可见性的问题。那么我们正确使用同步、锁的情况下，线程A修改了变量a何时对线程B可见？

我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before，从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。

**在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。**

happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。

JSR-133（Java内存模型规范）使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作（用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性）
- 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作（无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行 lock 操作）
- volatile 变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作C( happens-before 原则具备传递性)
- 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

# 二、volatile和synchronized

**1. 说说volatile和synchronized？**

**volatile**

volatile关键字有两个语义：

- 一是保证修饰的变量对所有其他线程的可见性。可见性指的是当一个线程修改了共享变量的值，其他线程可以立即得知这个修改，volatile保证新值能够立即同步回主存，以及每次使用前立即从主存刷新
- 二是禁止指令重排序。Java线程中如果操作之间不存在数据依赖关系，这些操作就能被编译器和处理器重排序，重排序时要保证as-if-serial，也就是不管怎么重排序，程序的执行结果不能被改变，而volatile修饰的变量会添加一个内存屏障，禁止将后面的指令重排序到内存屏障之前的位置

> 内存屏障：
>
> 在写volatile变量v之后，插入一个sfence（StoreStore Barriers）
>
> 在读volatile变量v之前，插入一个lfence（LoadLoad Barriers）
>
> https://blog.csdn.net/xindoo/article/details/90236236

**synchronized**

- synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行

- synchronized是可重入锁，一个线程可以多次对自己已经加锁的资源加锁，这种就是重入锁，通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁

- synchronized锁的资源只有两类：对象和类（.class），当对非static方法加锁时，锁的资源就是实例对象；对static方法加锁时，资源是该类（.class）

- synchronized修饰方法和修饰代码块的底层实现不同：

- - 修饰代码块：通过monitorenter进入，通过monitorexit释放锁
  - 修饰方法：在flags中设置ACC_SYNCHRONIZED标志，来告诉JVM这是一个同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。

> synchronized同步代码块：
>
> synchronized关键字经过编译之后，会在同步代码块前后分别形成monitorenter和monitorexit字节码指令，在执行monitorenter指令的时候，首先尝试获取对象的锁，如果这个锁没有被锁定或者当前线程已经拥有了那个对象的锁，锁的计数器就加1，在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。如果获取对象锁一直失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。
>
> 同步方法：
>
> 方法级的同步是隐式的，无须通过字节码指令来控制，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用的时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先持有monitor对象，然后才能执行方法，最后当方法执行完（无论是正常完成还是非正常完成）时释放monitor对象。在方法执行期间，执行线程持有了管程，其他线程都无法再次获取同一个管程。

**2. 说说volatile和synchronized的区别？**

- volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块
- volatile 关键字能保证数据的可见性，但不能保证操作的原子性。synchronized 关键字两者都能保证
- volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性

**3.volatile为什么不能保证原子性？**

volatile方式的i++，总共是四个步骤：

i++实际为load、Increment、store、Memory Barriers 四个操作。

内存屏障是线程安全的，但是内存屏障之前的指令并不是。在某一时刻线程1将 i 的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改 i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值 i == 10，自增1变为11，然后马上刷入主内存。此时由于线程2修改了 i的值，实时的线程1中的 i == 10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复，将自增过后的A寄存器值11赋值给cpu缓存 i 。这样就出现了线程安全问题。

> https://www.zhihu.com/question/329746124/answer/1205806238 写的很好

**4. synchronized为什么要优化？**

在JDK1.5之前，synchronized是重量级锁，1.6以后对其进行了优化，有了一个 无锁-->偏向锁-->自旋锁-->重量级锁 的锁升级的过程，而不是一上来就是重量级锁了。为什么呢？

因为重量级锁获取锁和释放锁需要经过操作系统，是一个重量级的操作。对于重量锁来说，一旦线程获取失败，就要陷入阻塞状态，并且是操作系统层面的阻塞，这个过程涉及用户态到核心态的切换，是一个开销非常大的操作。而研究表明，线程持有锁的时间是比较短暂的，也就是说，当前线程即使现在获取锁失败，但可能很快地将来就能够获取到锁，这种情况下将线程挂起是很不划算的行为。所以要对"synchronized总是启用重量级锁"这个机制进行优化。

在JVM中synchronized重量级锁的底层原理monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。

**5. 说说synchronized锁升级的过程？**

synchronized用的锁是存在Java对象头里的，在Java中，对象分为三部分：**对象头、实例数据、对齐填充**

![对象实例存储内容](http://longls777.oss-cn-beijing.aliyuncs.com/img/对象实例存储内容.png)

如果对象是数组类型，对象头有三个字宽；如果是非数组类型，对象头是两个字宽

| 长度     | 内容                   | 说明                           |
| -------- | ---------------------- | ------------------------------ |
| 32/64bit | MarkWord               | 存储对象的hashCode或锁信息等   |
| 32/64bit | Class Metadada Address | 存储对象类型数据的指针         |
| 32/64bit | Array Length           | 数组的长度(如果当前对象是数组) |

![32位JVM MarkWord](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230428172100266.png)

从JDK1.6开始，对synchronized锁进行了优化，分为以下四种：

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

**锁只能升级不能降级**

不同的锁对应的MarkWord标志位如下：

- 偏向锁：01
- 轻量级锁：00
- 重量级锁：10
- GC标记：11

![32位JVM不同的锁状态](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230428172242426.png)

**无锁->偏向锁**

- 在对象头和栈帧中的锁记录里储存锁偏向的线程ID，以后该线程进入和退出同步块时**不需要进行CAS操作来加锁和解锁, 只需要简单的测试一下锁对象的对象头的MarkWord里是否存储着指向当前线程的偏向锁**

- **当有两个线程来竞争该锁的话，那么偏向锁就失效了， 进而升级成轻量级锁**

**轻量级锁->重量级锁**

- 在锁竞争时，没有抢到锁的线程将**自旋**，不断地循环判断是否能够成功获取锁
- 自旋非常消耗资源，**当某个线程自旋次数达到最大时，轻量级锁就会升级为重量级锁**
- 重量级锁时，后续尝试获取锁的线程会**直接挂起**，等待被唤醒

**锁的比较：**

| 锁       | 优点                                                         | 缺点                                           | 适用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步代码方法的性能相差无几 | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗 | 适用于只有一个线程访问的同步场景   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行时间速度较长 |

**6. synchronized作用于静态方法？**

当synchronized作用于静态方法时，其**锁就是当前类的class对象锁**。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态成员的并发操作。

需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是**允许**的，不会发生互斥现象，因为访问**静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**

**7. 说说Monitor锁对象？**

重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是**monitor对象（也称为管程或监视器锁）的起始地址**。

每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。

在HotSpot虚拟机中，monitor是由**ObjectMonitor**实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;  //_owner指向持有ObjectMonitor对象的线程
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

ObjectMonitor中有两个队列，**_WaitSet 和 _EntryList**，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)；

**整个monitor运行的机制过程如下：**

_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕，也将释放monitor并复位count的值，以便其他线程进入获取monitor

具体见下图：

![monitor获取释放流程](http://longls777.oss-cn-beijing.aliyuncs.com/img/monitor获取释放流程.png)

**因此，monitor对象存在于每个Java对象的对象头中（存储的指针的指向），synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因**

> **notify/notifyAll和wait**方法：在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象。
>
> 我们知道**monitor 存在于对象头的MarkWord**中（存储monitor引用指针），而**synchronized关键字可以获取 monitor**，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法中调用的原因。
>
> 与**sleep方法**不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁（monitor），直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法**只让线程休眠并不释放锁**。
>
> 同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是**在相应的synchronized(){}/synchronized方法执行结束后**才自动释放锁。
>
> 摘自https://blog.csdn.net/mulinsen77/article/details/88635558

**8.什么是自旋锁和自适应自旋？**

如果持有锁的线程能在很短时间内释放锁资源，就可以让线程执行一个忙循环（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋需要消耗cpu的资源，如果一直得不到锁就会浪费cpu资源。因此在jdk1.6引入了自适应自旋锁，自旋等待的时候不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

**9.什么是锁消除？**

锁消除是指虚拟机即时编译器在运行时，对于一些代码上要求同步但是被检测不可能存在共享数据竞争的锁进行消除。例如String类型的连接操作，String是一个不可变对象，字符串的连接操作总是通过生成新的String对象来进行的，Javac编译器会对String连接做自动优化，在JDK1.5的版本中使用的是StringBuffer对象的append操作，StringBuffer的append方法是同步方法，这段代码在经过即时**编译器**编译之后就会忽略掉所有的同步直接执行。在JDK1.5之后是使用的StringBuilder对象的append操作来优化字符串连接的。

**10.什么是锁粗化？**

将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。例如每次调用StringBuffer.append方法都需要加锁，如果虚拟机检测到有一系列的连续操作都是对同一个对象反复加锁和解锁，就会将其合并成一个更大范围的加锁和解锁操作

> synchronized锁详解 https://blog.csdn.net/jinjiniao1/article/details/91546512

**11.synchronized在获锁的过程中的阻塞态能不能被中断？**

**synchronized在获锁的过程中的阻塞态是不能被中断的**， 原因是中断（thread.interrupt()）仅是会**设置该线程的中断状态位为true**，至于中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身（看你代码里怎么写，检测到中断状态为true后怎么做）

当如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、condition.await、以及可中断的通道上的 I/O 操作等方法后可进入阻塞状态），则在线程在检查中断标示时如果发现中断标示为true，则会在这些**阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为false**，抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。

也就是说，线程A在调用thread.interrupt()设置线程B中断状态为true后，如果线程B进入了阻塞状态，则线程中断，抛出异常。

> 而对于synchronized，如果一个线程在等待调用synchronized方法或进入synchronized代码块，这个线程此时并不是处于阻塞状态，而是处于**RUNNABLE**状态，也就不会因为线程中断状态被设置为true而中断。
>
> **这里对不对呢？有问题，以后研究**
>
> synchronized确实是等待获取锁的时候不可中断，拿到锁之后可中断，没获取到锁的情况下，中断操作一直不会生效

也就是说对于synchronized，如果一个线程在等待synchronized锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，**即使调用中断线程的方法，也不会生效**



> 一些解释，但是并没有给出原因
>
> https://blog.csdn.net/lmlzww/article/details/126336817
>
> https://juejin.cn/post/7020231777721516040
>
> https://cloud.tencent.com/developer/article/1622813

# 三、线程状态