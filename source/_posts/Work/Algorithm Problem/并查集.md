---
title: 并查集
date: 2023-04-27 15:30:00
tags: 并查集
categories: Algorithm Problem
math: true
---

## 并查集的原理

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-09fa3fa35e5411444b327d9cb9a31057_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-be12a6c795572d2acd77dcd49de35127_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-3c353bc781c7f3553079d541a9cfdc28_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-6362d8b13705d5ba17b19cdeee453022_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-cca3ddf5806a221201ed78caf1d27041_720w.webp)

并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题

并查集通常包含两种操作：

- **查找(Find)：查询两个元素是否在同一个集合中**

- **合并(Union)：把两个不相交的集合合并为一个集合**

  

## 并查集代码最初版

**初始化**

```c++
int fa[MAXN];
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
        fa[i] = i;
}
```

假如有编号为1, 2, 3, ..., n的n个元素，我们用一个数组fa[]来存储每个元素的父节点，一开始，它们的父节点是自己

**查询**

```c++
int find(int x)
{
    if(fa[x] == x)
        return x;
    else
        return find(fa[x]);
}
```

我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点为本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同

**合并**

```c++
void merge(int i, int j)
{
    fa[find(i)] = find(j);
}
```

合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可，当然也可以将后者的父节点设为前者，这里暂时不重要

## 路径压缩

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-23c367515ace6fc0603692dfd865849f_720w.webp)

问题：链条太长了，查询费时

解决方法：**把沿途的每个节点的父节点都设为根节点**



**查询（路径压缩）**

```c++
int find(int x)
{
    if(x == fa[x])
        return x;
    else{
        fa[x] = find(fa[x]);  //父节点设为根节点
        return fa[x];         //返回父节点
    }
}
```

以上代码常常简写为一行：

```c++
int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}
```

> 注意赋值运算符 = 的优先级没有三元运算符高，这里要加括号

## 按秩合并

由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.webp)

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-96fbb25365b43f0a109bec6d55b3b899_720w.webp)

如果把7的父节点设为8，会使树的**深度**（树中最长链的长度）加深，而把8的父节点设为7，则不会有这个问题，所以右边的更好

所以**应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少**

用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的**子树**的深度）。一开始，把所有元素的rank（**秩**）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。

路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n) ，但是很可能会破坏rank的准确性

**初始化（按秩合并）**

```c++
void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i;
        rank[i] = 1;
    }
}
```

**合并（按秩合并）**

```c++
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);    //先找到两个根节点
    if (rank[x] <= rank[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (rank[x] == rank[y] && x != y)
        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1
}
```

为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-de356190829600f438058e8615c7a5ac_720w.webp)

这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：

![img](http://longls777.oss-cn-beijing.aliyuncs.com/img/v2-a829932f008f000440942cb8df393662_720w.webp)

显然树的深度增加了1，所以让rank[y]++