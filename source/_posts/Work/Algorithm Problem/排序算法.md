---
title: 排序算法
date: 2023-10-07 15:45:00
tags: 排序
categories: Algorithm Problem
math: true
---

## **1. 冒泡排序**

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。

在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。

时间复杂度为$O(n^2)$

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int n = nums.length;
        boolean isSorted = false;
        for(int i=0;i<n-1&&!isSorted;i++){
            isSorted = true;
            for(int j=0;j<n-i-1;j++){
                if(nums[j]>nums[j+1]){
                    isSorted = false;
                    swap(nums,j,j+1);
                }
            }
        }
        return nums;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int n = nums.length;
        for(int i=n-1;i>0;i--)
            for(int j=0;j<i;j++)
                if(nums[j]>nums[j+1])
                    swap(nums,j,j+1);
        return nums;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## **2. 插入排序**

时间复杂度为$O(n^2)$

![](https://longls777.oss-cn-beijing.aliyuncs.com/img/07f6a41e574.webp)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=1;i<nums.length;i++){
            int insertVal = nums[i];
            int insertIdx = i-1;
            while(insertIdx>=0&&nums[insertIdx]>insertVal){
                nums[insertIdx+1] = nums[insertIdx];
                insertIdx--;
            }
            if(insertIdx+1!=i)
                nums[insertIdx+1] = insertVal;
        }
        return nums;
    }
}
```

## **3. 选择排序**

**冒泡排序与选择排序的区别**

冒泡排序是将“最大值”不断移向最后，比如第一次遍历，将全部数的最大值移到最后一个位置，第二次遍历，将从开始到倒数第二个数中的最大值移到倒数第二个位置，以此类推。过程中可能存在多次交换；

选择排序是首先将第一个数到最后中的最小值与第一个数交换，然后从第二个数开始，一直到最后，找出最小值，与第二个数交换，以此类推。在一次遍历中有且只交换一次。

时间复杂度为$O(n^2)$

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n-1;i++){
            int min = nums[i];
            int index = i;
            for(int j=i+1;j<n;j++)
                if(nums[j]<min){
                    min = nums[j];
                    index = j;
                }
            swap(nums,i,index);
        }
        return nums;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## **4. 希尔排序**

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破$O(n^2)$的第一批算法之一

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

希尔排序的时间复杂度比较模糊，它取决于增量，大概范围是$O(n^{1.3})$ ~ $O(n^{2})$ ，但是可以肯定的是希尔排序比直接插入排序要更有效率

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int temp = 0;
        int count = 0;
        for(int gap=nums.length/2;gap>0;gap/=2)
            for(int i=gap;i<nums.length;i++)
                for(int j=i-gap;j>=0;j-=gap)
                    if(nums[j]>nums[j+gap])
                        swap(nums,j,j+gap);
        return nums;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**原理：**

最外层循环是增量gap，中间层的 i 从gap开始，即从第一个分组的第二个元素开始，也就是说跳过所有分组的第一个元素，以便接下来进行判断，交换位置；

最里层 j 从 i-gap开始，也就是从 i 所在分组的前一个元素开始判断，j 递减gap，一直到0，也就是将 arr[i]移到所在分组的排序后的位置，也就是之前的插入排序；

i 一直遍历到arr.length，从而将所有分组的所有元素（从第二个开始）都在所在分组进行了插入排序，最后随着gap折减到0，排序完成

## **5. 归并排序**

归并排序的时间复杂度是$O(nlogn)$

![](https://longls777.oss-cn-beijing.aliyuncs.com/img/328d47b728f.webp)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int[] temp = new int[nums.length];
        mergeSort(nums,0,nums.length-1,temp);
        return nums;
    }
    private void mergeSort(int[] nums,int left,int right,int[] temp){
        if(left<right){
            int mid = (left+right)/2;
            mergeSort(nums,left,mid,temp);
            mergeSort(nums,mid+1,right,temp);
            merge(nums,left,mid,right,temp);
            }
    }
    private void merge(int[] nums,int left,int mid,int right,int[] temp){
        int i = left, j = mid+1;
        int t = 0;
        while(i<=mid&&j<=right){
            if(nums[i]<=nums[j])
                temp[t++] = nums[i++];
            else
                temp[t++] = nums[j++]; 
        }
        while(i<=mid)
            temp[t++] = nums[i++];
        while(j<=right)
            temp[t++] = nums[j++];
        t = 0;
        int cur = left;
        while(cur<=right)
            nums[cur++] = temp[t++];
    }
}
```

## **6. 堆排序**

最坏，最好．平均时间复杂度均为$O(nlogn)$，是不稳定排序（不能保证相同的两个数的位置和原来一样)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=nums.length/2-1;i>=0;i--)
            adjustHeap(nums,i,nums.length);
        for(int j=nums.length-1;j>0;j--){
                swap(nums,j,0);
            adjustHeap(nums,0,j);
        }
        return nums;
    }
    private void adjustHeap(int[] nums,int i,int length){
        for(int k=i*2+1;k<length;k=k*2+1){
            if(k+1<length&&nums[k]<nums[k+1])
                k++;
            if(nums[k]>nums[i]){
                swap(nums,i,k);
                i = k;
            }else
                break;
        }
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## **7. 基数排序**

基数排序法的时间复杂度为$O (nlog(r)m)$，其中$r$为所采取的基数，而$m$为堆数

```java
public static void radixSort(int[] arr){
        int max=arr[0];
        for(int i=0;i<arr.length;i++){
            max=max>arr[i]?max:arr[i];
        }
        int maxLength=(max+"").length();//数字最大位数
        int[][] bucket=new int[10][arr.length];//十个桶子，每个深为arr.length
        int[] bucketElementCounts=new int[10];//用于记录每个桶子里面存放了几个数据，便于取出
        for(int i=0,n=1;i<maxLength;i++,n*=10){//次数为数字最大位数的循环
            for(int j=0;j<arr.length;j++)//依次放入桶子
            {
                int digitOfElement=arr[j]/n%10;
                bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index=0;
            for(int k=0;k<10;k++){//依次取出
                if(bucketElementCounts[k]!=0){
                    for(int m=0;m<bucketElementCounts[k];m++)
                        arr[index++]=bucket[k][m];
                }
                bucketElementCounts[k]=0;//记得将桶子中存放个数清零 
            }
        }
    }
```

## **8. 快速排序**

**算法描述**

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

快速排序的平均时间复杂度是$O(nlogn)$，最坏情况是$O(n^2)$

```java
class Solution {
    public int[] sortArray(int[] nums) {
        if(nums!=null)
            quickSort(nums,0,nums.length-1);
        return nums;
    }
    public void quickSort(int[] nums,int left,int right){
        if(left>=right) return;
        int t = partition(nums,left,right);
        quickSort(nums,left,t);
        quickSort(nums,t+1,right);
    }
    public int partition(int[] nums,int left,int right){
        int l = left,r = right;
        int x = nums[left];
        while(l<r){
            while(r>l&&nums[r]>=x)
                r--;
            while(l<r&&nums[l]<=x)
                l++;
            swap(nums,l,r);
        }
        swap(nums,left,l);
        return l;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**性能分析**

- 快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈
- 快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为$ CN=2CN/2+N$，复杂度为 $O(NlogN)$
- 最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 $N^2/2$，最坏时间复杂度为$O(N^2)$。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组

**算法改进**

- 切换到插入排序：因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序

- 三数取中：最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素

- 三向切分：对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序

```java
//三向切分
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {

    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0) {
                swap(nums, lt++, i++);
            } else if (cmp > 0) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}
```

**基于切分的快速选择算法（求数组的第K个最大元素）**

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。

可以利用这个特性找出数组的第 k 个元素。

该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N

```java
public T select(T[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (h > l) {
        int j = partition(nums, l, h);

        if (j == k) {
            return nums[k];

        } else if (j > k) {
            h = j - 1;

        } else {
            l = j + 1;
        }
    }
    return nums[k];
}
```

