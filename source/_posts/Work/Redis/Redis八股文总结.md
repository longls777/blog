---
title: Redis八股总结
tags: 八股
categories: Redis
date: 2023-3-20 14:59:00
index_img: 
banner_img: 
math: true
---

> [JavaGuide-redis](https://javaguide.cn/database/redis/redis-questions-01.html)
>
> https://blog.csdn.net/weixin_47188125/article/details/125706438



## 一、什么是Redis？

Redis 是一个基于 C 语言开发的开源的高性能非关系型数据库（Nosql），是一个高性能的key-value数据库，与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向，每秒可以处理超过10w次读写操作，是已知性能最快的key-value DB

为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如String，List，Set， Zset，Hash）。此外，Redis也经常用来做分布式锁，并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）等

## 二、关系型数据库和非关系型数据库的区别？

关系型数据库是指采用了关系模型来组织数据的数据库，关系模型指的就是二维表格模型，数据按照表的形式存储，然后多组表构成了一个数据库

**优点：**

1. 易于维护：都是使用表结构，格式一致
2. 使用方便：支持SQL语言，可用于复杂查询

**缺点：**

1. 读写性能比较差，尤其是海量数据的高效率读写
2. 固定的表结构，灵活性差
3. 对于高并发读写需求，硬盘I/O是一个很大的瓶颈



非关系型数据库严格上不是一种数据库，应该是一种**数据结构化存储方法的集合**，可以是文档或者键值对等

**优点：**

1. 格式灵活：存储数据格式可以是key-value格式，文档格式，图片格式等等，使用灵活，应用场景广泛，而关系型数据库只支持基础的数据类型
2. 速度快：Nosql可以使用硬盘或者随机存储器（RAM，内存）作为载体，而关系型数据库只能使用硬盘
3. 高扩展性：Nosql基于键值对，数据之间没有耦合性，所以非常容易水平扩展

**缺点：**

1. 不支持SQL
2. 无事务处理（ACID）
3. 只适合存储一些较为简单的数据，需要进行较复杂查询的数据，关系型数据库显的更为合适



## 三、Redis为什么这么快？

Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：

- Redis 基于内存，内存的访问速度是磁盘的上千倍
- Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用
- Redis 内置了多种优化过后的数据结构实现，性能非常高

> 单机Redis读的速度是11w次/s，写的速度是8.1w次/s

![why-redis-so-fast](http://longls777.oss-cn-beijing.aliyuncs.com/img/why-redis-so-fast.d3507ae8.png)



## 四、为什么要用 Redis/为什么要用缓存？

主要从**高性能**和高并发这两个角度来看待问题

**高性能：**

假如用户第一次访问数据库中的某些数据，这个过程是比较慢的，因为是从硬盘上直接读取的。将该用户访问的数据存储在缓存中，这样下次再次访问这些数据的时候，就可以直接去缓存中拿了。操作缓存就是直接操作内存，所以速度特别快。数据库中的数据改变后，同步改变缓存中相应的数据即可

**高并发：**

直接操作缓存所能承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户中的一部分请求会直接到缓存中，而不是数据库

一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）



## 五、Redis 除了做缓存，还能做什么？

**分布式锁** ： 通过 Redis 来做分布式锁是一种比较常见的方式 ，通常情况下，我们都是基于 Redisson 来实现分布式锁

> [分布式锁详解](https://javaguide.cn/distributed-system/distributed-lock.html) 

**限流** ：一般是通过 Redis + Lua 脚本的方式来实现限流       

> [《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》](https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA)

**消息队列** ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制  

> [Redis 消息队列发展历程 - 阿里开发者 - 2022](https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw)

**复杂业务场景** ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜



## 六、Redis数据结构有哪些？

关于Redis的数据结构请查看本站文章《Redis的数据结构》



## 七、String 还是 Hash 存储对象数据更好？

- String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合
- String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合

在绝大部分情况，建议使用 String 来存储对象数据



## 八、相比于C语言的字符串，SDS的好处是什么？

1. **可以避免缓冲区溢出** ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作
2. **获取字符串长度的复杂度较低** ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)
3. **减少内存分配次数** ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有相应的 API）
4. **二进制安全** ：C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题



## 九、讲讲Redis线程模型？

对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）

#### Redis单线程模型

**Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型** （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。

> [Reactor模式介绍](https://zhuanlan.zhihu.com/p/428693405)



《Redis 设计与实现》有一段话是如是介绍文件事件处理器的：

> Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。
>
> - 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
> - 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
>
> **虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。



**既然是单线程，那怎么监听大量的客户端连接呢？**

Redis 通过 **IO 多路复用程序** 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生

这样的好处非常明显： **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**（和 NIO 中的 `Selector` 组件很像）

文件事件处理器（file event handler）主要是包含 4 个部分：

- 多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

![文件事件处理器](http://longls777.oss-cn-beijing.aliyuncs.com/img/redis-event-handler.png)

> [Redis 事件机制详解](http://remcarpediem.net/article/1aa2da89/) 



#### Redis6.0 之前为什么不使用多线程？

- 单线程编程容易并且更容易维护
- Redis 的性能瓶颈不在 CPU ，主要在内存和网络
- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能

> [为什么 Redis 选择单线程模型](https://draveness.me/whys-the-design-redis-single-thread/) 

#### Redis6.0 之后为何引入了多线程？

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题

Redis6.0 的多线程默认是禁用的，只使用主线程。官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启



## 十、Redis的过期键删除策略有哪些？

过期键删除策略通常有以下三种

1. **定时删除**：在设置键的过期时间的同时，创建一个定时器（timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存很友好，但是会占用大量CPU去处理过期的数据，从而影响响应时间和吞吐量
2. **惰性删除**：只有当访问一个key时，才会去判断这个Key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，但对内存十分不友好，极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存
3. **定期删除**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果



## 十一、说说Redis内存淘汰机制？

> 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？

Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least recently used）**：从过期字典（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从过期字典（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从过期字典（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错

4.0 版本后增加以下两种：

1. **volatile-lfu（least frequently used）**：从过期字典（server.db[i].expires）中挑选最不经常使用的数据淘汰
2. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

#### 也可以这样划分：

**全局的键空间选择性移除**

- no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（常用）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key

**设置过期时间的键空间选择性移除**

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中， 移除最近最少使用的key
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除将要过期的key，ttl的值越大优先被移除

> Redis的内存淘汰策略的选取并不会影响过期的key的处理
>
> - 内存淘汰策略用于处理内存不足时的需要申请额外空间的数据
> - 过期策略用于处理过期的缓存数据
>
> 关于键的过期实现，请查看本站文章《Redis键的过期实现》



## 十二、说说Redis持久化机制——RDB 和 AOF？

**RDB持久化**可以在指定时间间隔内生成数据集的时间点快照

在默认情况下， Redis将内存数据库快照保存在名字为dump.rdb 的二进制文件中

`save 60 1000 //关闭RDB只需要将所有的save保存策略注释掉即可`

以上设置会让Redis在满足“60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集： 



**AOF持久化**是记录服务器执行的所有读写操作命令，并在服务器启动时，通过执行这些命令来还原数据集。AOF文件中的命令全部以Redis协议的格式来保存，新命令会被追加到文件的末尾

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 `server.aof_buf` 中，然后再根据 `appendfsync` 配置来决定何时将其同步到硬盘中的 AOF 文件



> 可以配置 Redis 多久才将数据 fsync 到磁盘一次。 有三个选项：
>
> 1. appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全
> 2. appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据
> 3. appendfsync no：从不fsync ，将数据同步交给操作系统来处理。更快，也更不安全的选择
>
> 为了兼顾数据和写入性能，用户可以考虑 `appendfsync everysec` 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据



Redis还可以在后台对AOF文件进行重写，使AOF文件的体积不会超出保存数据集状态所需的实际大小

Redis还可以同时使用RDB和AOF持久化。在这种情况下，当Redis重启时，他会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整

![image-20230320163536954](http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20230320163536954.png)



## 十三、RDB 创建快照时会阻塞主线程吗？

Redis 提供了两个命令来生成 RDB 快照文件：

- `save` : 同步保存操作，会阻塞 Redis 主线程
- `bgsave` : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项



## 十四、比较一下AOF和RDB

**RDB 比 AOF 优秀的地方** ：

- RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， **Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次**
- 使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快

**AOF 比 RDB 优秀的地方** ：

- RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量
- RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题
- AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行`FLUSHALL`命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态







## 九十九、Redis的优缺点？

**优点：**

1. 读写性能优异
2. 支持数据持久化——AOF持久化和RDB持久化
3. 支持事务，Redis的所有操作都是原子性的
4. 数据结构丰富，除了支持String类型之外，还支持hash，set，zset，list等数据结构
5. 支持主从复制，主机会自动将数据同步到从机，可进行**读写分离**

**缺点：**

1. 数据库容量容易受到物理内存的限制，不能用作高性能海量数据读写，因此Redis主要适用于较小数据量的高性能操作和运算上
2. Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写需求失败，需要等待机器重启或者手动切换前端的IP才能恢复
3. 主机宕机，宕机前有部分数据未能同步到从机，切换IP后会引入数据不一致的问题
4. Redis较难支持在线扩容，在集群容量达到上限时，扩容会变得很复杂；所有运维人员在系统上线时必须确保足够的空间，这对资源造成很大的浪费

> **关于读写分离**
>
> 随着业务的不断扩大，请求的并发量不断增长，Redis可能终会出现无法负载的情况，此时我们就需要想办法去提升Redis的负载能力
>
> 读写分离（主从复制）是一个比较简单的扩展方案，使用多台机器同时运行Redis服务，一台负责写服务，多台负责读服务，通过多台服务器对请求进行负载，大大提高了Redis服务的负载压力。这样从节点也可以支持横向扩展，来继续提高读的吞吐量
>
> ![Redis读写主从分离](https://img-blog.csdnimg.cn/img_convert/f332a6c58c2db4454ccc5c9f04d6766c.webp?x-oss-process=image/format,png)
